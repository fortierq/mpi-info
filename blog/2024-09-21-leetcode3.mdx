---
title: LeetCode 3
authors: qfortier
tags: [leetcode, devoir, programmation]
---

Exercice à faire en C sur LeetCode, au plus tard pour samedi prochain : https://leetcode.com/problems/number-of-islands

<details>
<summary>Indice</summary>

Cela revient à calculer les composantes connexes du graphe dont les sommets sont les cases de la grille et où chaque case a 4 arêtes possibles avec les cases voisines.  
Pour calculer le nombre de composantes connexes, on peut utiliser un parcours en profondeur (ou en largeur). On peut directement utiliser `grid` comme tableau des vus (en mettant une case à '0' après l'avoir visitée).

```c
// Parcours en profondeur
void dfs(char** grid, int n, int p, int i, int j) {
    ...
}

int numIslands(char** grid, int gridSize, int* gridColSize) {
    int n = gridSize, p = gridColSize[0]; // n lignes, p colonnes
    int k = 0; // nombre de composantes connexes
    for(int i = 0; i < n; i++)
        for(int j = 0; j < p; j++)
            ...
    return k;
}
```

</details>

Si vous avez terminé l'exercice, vous pouvez faire ce prolongement (plus difficile) : https://leetcode.com/problems/merge-k-sorted-lists

<details>
<summary>Indice</summary>

Réutiliser la fonction précédente pour fusionner deux listes.  
L'idéal est de résoudre ce problème en O(n log k) où n est la somme des tailles des listes et k le nombre de listes.
</details>
