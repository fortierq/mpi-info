---
hide_table_of_contents: false
hide_title: false
cor: true
title: "TP 3 : Algorithme de Berry-Sethi"
---

## Fonctions utilitaires

On utilisera le type suivant d'expression régulière : 

```ocaml
type 'a regexp = 
    | Vide | Epsilon | L of 'a
    | Union of 'a regexp * 'a regexp
    | Concat of 'a regexp * 'a regexp
    | Etoile of 'a regexp
```

1. Écrire une fonction `fusion : 'a list -> 'a list -> 'a list` telle que, si `u` et `v` sont strictement croissantes, `fusion u v` est une liste strictement croissante contenant tous les éléments de `u` et de `v`. 
2. Écrire une fonction `est_vide : 'a regexp -> bool` déterminant si le langage d'une expression régulière est vide.
3. Écrire une fonction `a_epsilon : 'a regexp -> bool` déterminant si une expression régulière contient $\epsilon$.
4. Donner la complexité des fonctions précédentes.

## Calcul des ensembles $P(L)$, $S(L)$, $F(L)$

Revoir si besoin dans le cours les définitions des ensembles $P(L)$, $S(L)$, $F(L)$. 

5. Écrire sur papier des équations de récurrence pour les ensembles $P(L)$, $S(L)$, $F(L)$.  
6. Écrire une fonction `p : 'a regexp -> 'a list` renvoyant l'ensemble $P(L)$ d'une expression régulière, sous forme de liste strictement croissante. 
```ocaml
p (Union (Concat(L 1, L 3), L 2));;
- : int list = [1; 2]
p (Concat (L 1, Vide));;
- : int list = []
p (Concat (Concat(L 1, L 3), L 2));;
- : int list = [1]
p (Concat (Epsilon, L 2));;
- : int list = [2]
```
7. Écrire une fonction `s : 'a regexp -> 'a list` renvoyant l'ensemble $S(L)$ d'une expression régulière, sous forme de liste strictement croissante.
8. Écrire une fonction `produit : 'a list -> 'b list -> ('a * 'b) list` renvoyant le produit cartésien de deux listes. Par exemple, `produit [1; 2] [1; 3]` peut renvoyer `[(1, 3); (1, 1); (2, 3); (2; 1)]` (l'ordre des éléments de la liste de retour n'importe pas).  
9. Écrire une fonction `f : 'a regexp -> ('a * 'a) list` renvoyant l'ensemble $F(L)$ d'une expression régulière, sous forme de liste de couples strictement croissants.

## Linéarisation d'une expression régulière

10. Écrire une fonction `n_lettres : 'a regexp -> int` renvoyant le nombre de lettres d'une expression régulière. Par exemple, `n_lettres (Union (Concat (L 'a', L 'b'), Etoile (L 'a')))` doit renvoyer `3`.  
11. Écrire une fonction `lineariser : 'a regexp -> int regexp` renvoyant la linéarisation d'une expression régulière, où les lettres sont numérotées par des entiers croissants à partir de $1$.  
Par exemple, `lineariser (Union (Concat (L 'a', L 'b'), Etoile (L 'a')))` doit renvoyer `Concat (L 1, Concat (L 2, Etoile (L 3)))`.

## Automate de Glushkov

L'automate de Glushkov n'est pas forcément détérministe. On utilisera le type suivant, où les lettres sont numérotées par des entiers et $0$ est l'état initial :
    
```ocaml
type automate = { 
    delta : int list array array;
    finaux : bool array;
}
```
Ainsi, si `a` est un automate, `a.delta.(i).(j)` est la liste des états atteignables depuis l'état `i` avec la lettre `j`. `a.finaux.(i)` est vrai si l'état `i` est final.

12. Écrire une fonction `glushkov : 'a regexp -> automate` renvoyant l'automate de Glushkov d'une expression régulière.

{/* %     \section{Calcul des ensembles $P(L)$, $S(L)$, $F(L)$}
% 	Soit $L$ un langage. On rappelle les définitions du cours :
% 	\begin{itemize}
% 		\item $P(L)$ = $\s{a \in \Sigma \tq a\Sigma^*\cap L \neq \emptyset}$ (premières lettres des mots de L)
% 		\item $S(L) = \s{a \in \Sigma \tq \Sigma^* a \cap L \neq \emptyset}$ (dernières lettres des mots de L)
% 		\item $F(L) = \s{u \in \Sigma^2 \tq \Sigma^* u \Sigma^* \cap L \neq \emptyset}$ (fs de longueur 2 des mots de L)
% 	%	\item $N(L) = \Sigma^2 \backslash F(L)$ %(les mots de longueur 2 qui ne sont pas f d'un mot de $L$).
% 	\end{itemize}
% 	Dans la suite, on utilise le type suivant d'expression régulière : \begin{center}
% 		\begin{code}{ocaml}
% type 'a regexp = 
% 	| Vide | Epsilon | L of 'a
% 	| Union of 'a regexp * 'a regexp
% 	| Concat of 'a regexp * 'a regexp
% 	| Etoile of 'a regexp
% 		\end{code}
% 	\end{center}
% 	\begin{enumerate}
% 		\item Écrire une fonction \ocaml{has_eps : 'a regexp -> bool} déterminant si le langage d'une expression régulière contient $\epsilon$. 
% 		\if\cor1\\
% 		\begin{emphase}
% 			\underline{Solution} : \begin{center}
% 				\begin{code}{ocaml}
% let rec has_eps = function
% 	| Vide | L _ -> false
% 	| Epsilon | Etoile _ -> true
% 	| Union (e1, e2) -> has_eps e1 || has_eps e2
% 	| Concat (e1, e2) -> has_eps e1 && has_eps e2
% 				\end{code}
% 			\end{center}
% 		\end{emphase}
% 		\fi  
% 		\item Écrire une fonction \ocaml{fusion : 'a list -> 'a list -> 'a list} telle que, si \ocaml{l1} et \ocaml{l2} sont des listes sans doublon (ce qu'on suppose être le cas...), \ocaml{fusion l1 l2} renvoie une liste sans doublon contenant les éléments des deux listes. Par exemple, \ocaml{fusion [1; 2] [3; 1]} peut renvoyer \ocaml{[1; 2; 3]} (l'ordre des éléments de la liste de retour n'importe pas).
% 		\if\cor1\\
% 		\begin{emphase}
% 			\underline{Solution} : \begin{center}
% 				\begin{code}{ocaml}
% let rec fusion l1 l2 = match l1 with
% 	| [] -> l2
% 	| a::q1 -> if List.mem a l2 then fusion q1 l2 else a::(fusion q1 l2)
% 				\end{code}
% 			\end{center}
% 		\end{emphase}
% 		\fi
% 		\item Écrire une fonction \ocaml{p} de type \ocaml{'a regexp -> 'a list} telle que \ocaml{p e} renvoie $P(L($\ocaml{e}$))$.
% 		\if\cor1\\
% 		\begin{emphase}
% 			\underline{Solution} : \begin{center}
% 				\begin{code}{ocaml}
% let rec p = function
% 	| Vide | Epsilon -> []
% 	| L a -> [a]
% 	| Union (e1, e2) -> fusion (p e1) (p e2)
% 	| Concat (e1, e2) -> if has_eps e1 then fusion (p e1) (p e2) else p e1
% 	| Etoile e -> p e
% 				\end{code}
% 			\end{center}
% 		\end{emphase}
% 		\fi
% 		\item Que faudrait-il modifier à \ocaml{p} pour obtenir une fonction \ocaml{s} renvoyant $S(L)$?
% 		\if\cor1\\
% 		\begin{emphase}
% 			\underline{Solution} : Échanger \ocaml{e1} et \ocaml{e2} dans \ocaml{Concat(e1, e2) -> ...}
% 		\end{emphase}
% 		\fi
% 		\item Écrire une fonction \ocaml{produit : 'a list -> 'b list -> ('a * 'b) list} effectuant le produit cartésien de 2 listes : si \ocaml{l1} et \ocaml{l2} sont des listes, \ocaml{produit l1 l2} renvoie une liste de tous les couples distincts composés d'un élément de \ocaml{l1} et un élément de \ocaml{l2}. Par exemple, \ocaml{produit [1; 2] [3; 1]} peut renvoyer \\
% 		\ocaml{[(1, 3); (1, 1); (2, 3); (2; 1)]} (l'ordre des éléments de la liste de retour n'importe pas).
% 		\if\cor1\\
% 		\begin{emphase}
% 			\underline{Solution} : Avec \ocaml{List.map} :\begin{center}
% 				\begin{code}{ocaml}
% let rec produit l1 l2 = match l1 with
% 	| [] -> []
% 	| a::q1 -> List.map (fun b -> (a, b)) l2 @ produit q1 l2
% 				\end{code}
% 			\end{center}
% 		Sans \ocaml{List.map} :\begin{center}
% 				\begin{code}{ocaml}
% let rec produit l1 l2 = match l1 with
% 	| [] -> []
% 	| a::q1 -> let rec aux l2 = match l2 with
% 		| [] -> []
% 		| b::q2 -> (a, b)::aux q2
% 		in aux l2 @ produit q1 l2
% 				\end{code}
% 			\end{center}
% 		\end{emphase}
% 		\fi
% 		\item En déduire une fonction \ocaml{f} de type \ocaml{'a regexp -> ('a * 'a) list} telle que \ocaml{f e} renvoie $F(L($\ocaml{e}$))$. 
% 		\if\cor1\\
% 		\begin{emphase}
% 			\underline{Solution} : \begin{center}
% 				\begin{code}{ocaml}
% let rec f = function
% 	| Vide | Epsilon | L _ -> []
% 	| Union (e1, e2) -> fusion (f e1) (f e2)
% 	| Concat (e1, e2) -> fusion (f e1) (fusion (produit (s e1) (p e2)) (f e2))
% 	| Etoile e -> fusion (f e) (produit (s e) (p e))
% 				\end{code}
% 			\end{center}
% 		\end{emphase}
% 		\fi
% 	\end{enumerate} */}